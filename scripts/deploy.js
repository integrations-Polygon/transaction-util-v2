const ethers = require('ethers');
const fs = require('fs');
const hre = require("hardhat");
require('dotenv').config()
const fetch = require('node-fetch');



// env variables 
const privateKey = process.env.SIGNER_PRIVATE_KEY
const projectID = process.env.PROJECT_ID
const network = process.env.NETWORK


const Deployment = async (network, projectID) => {
  try{

    // Set initial txReceipt and gas price and gasIncrement
		let gasPrice = 0
		let txReceipt = null
    let gasIncrement = 0 //gas incrementation in case tx fails

    // later we can change this to mumbai
    // Configuring the connection to an Rinkeby node
    const provider = new ethers.providers.InfuraProvider(
    network,
    projectID
    );

    // Use your wallet's private key to deploy the contract
    const wallet = new ethers.Wallet(privateKey, provider)

    // Read the contract artifact, which was generated by Hardhat
    const metadata = JSON.parse(fs.readFileSync('./artifacts/contracts/Demo.sol/Demo.json'))

    while(txReceipt == null) {

      // Fetch the gas fee estimation from the Polygon Gas Station V2 Endpoint
      const gasData = await fetchGasPrice()
      const gasLimit = 200000;
      const gasInGWEI = gasData.fastest 
      gasPrice = gasInGWEI * 10**9 + gasIncrement
      gasIncrement += 10000

      // Set gas limit and gas price
      const options = {gasLimit: gasLimit, gasPrice: gasPrice}

      // Deploy the contract
      const factory = new ethers.ContractFactory(metadata.abi, metadata.bytecode, wallet)
      const contract = await factory.deploy(options)
      
      // Get the transaction hash after the deployment
      const txHash = await contract.deployTransaction.hash

      console.log("The contract is being mined...\n")
	    console.log(`The gas price being used is ${gasInGWEI} GWEI.`)
	    console.log(`The generated transaction hash is ${txHash}.\n`)
	    console.log('While your contract is being mined, you can check your transaction at:');
      console.log(`https://rinkeby.etherscan.io/tx/${txHash}\n`)
      
      // Wait for confirmation and get the txReceipt
      txReceipt = await waitForConfirmation(provider, txHash)

      if(txReceipt == null) {
				console.log("\nTransaction failed...Trying again!\n");
			}

      // Store failed txReceipt in DB
      await saveReceipt(contract.address, txReceipt)

    }

    // Wait for the contract to get mined
    await contract.deployed()
    console.log(`Deployment successful! Contract Address: ${contract.address}`)

    // Return the success receipt
    return txReceipt

  } catch (error) {
		console.log("error in Deployment", error)
		return "error in Deployment"
	}
}

const waitForConfirmation = async (provider, txHash) => {

	try {
		let i = 0
		while(i < 12) {
			if(await isConfirmed(provider, txHash, 12)) {

				console.log(txHash, ' was confirmed by 12 blocks')

				// Returns the transaction receipt for the txHash
				const txReceipt = await provider.getTransactionReceipt(txHash)

				// Returns the txReceipt if the txReceipt is not null
				if(txReceipt != null) return txReceipt
			}
			// Increment i
			i += 1
			
			// Wait for 15000 ms and check if the transaction gets 12 block confirmation on the next run
			await sleep(15000)
		}
		return null
	} catch (error) {
		console.log("error in waitForConfirmation", error)
		return null
	}
}

const isConfirmed = async (provider, txHash, blocks) => {
	try {
		// Returns the transaction's hash
		const tx = await provider.getTransaction(txHash)

		if(!tx || !tx.blockNumber) {
			return false
		}

		// Returns the most recently mined blockNumber
		const lastestBlockNumber = await provider.getBlockNumber()
		
		// Check if the block confirmation is more than or equal to 12 blocks
		if(lastestBlockNumber - tx.blockNumber >= blocks) {
			return true
		} else {
			return false
		}
	} catch (error) {
		console.log("error in isConfirmed", error)
		return false
	}
}

const saveReceipt = async (address, txReceipt) => {
  const resultFile = "result.json"
  const result = JSON.parse(fs.readFileSync(path.resolve(__dirname, resultFile)).toString())
  if (txReceipt.status == false) {
      result[address] = 'reverted'
      fs.writeFileSync(resultFile, JSON.stringify(result, null, 2)) // Indent 2 spaces
      return
  } else {
      result[address] = txReceipt.transactionHash
      fs.writeFileSync(path.resolve(__dirname, resultFile), JSON.stringify(result, null, 2)) // Indent 2 spaces
  }
}

async function fetchGasPrice() {
  return (await fetch("https://ethgasstation.info/api/ethgasAPI.json")).json();
}

function sleep(ms) {
return new Promise(resolve => setTimeout(
  resolve,
  ms
))
}

async function startDeployment() {
	console.log("\nStarting the transaction process.\n")
	console.log("Fetching all the necessary data to start mining.\n")
	let txReceipt = await Deployment(network, projectID)

	// Store the success txReceipt in DB
  await saveReceipt(contract.address, txReceipt)
  
}

startDeployment()
	.then(() => {
		console.log("Deployment was successful and confirmed by 12 blocks.\n")
		process.exit(0)
	})
	.catch((error) => {
		console.error(error)
		process.exit(1)
	}
)    