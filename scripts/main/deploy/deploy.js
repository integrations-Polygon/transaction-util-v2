const ps = require("prompt-sync")
const prompt = ps()
const fs = require('fs')
require('dotenv').config()
const hre = require("hardhat")
const ethers = require('ethers')
const redisDB = require("../utils/redisDB")
const handleDeployTx = require("./handleDeployTx")
const saveReceipt = require("../utils/saveReceipt")
const dataMapping = require("../utils/dataMapping")
const waitForConfirmation = require("../utils/waitForComfirmation")


// env variables 
const privateKey = process.env.SIGNER_PRIVATE_KEY
const projectID = process.env.PROJECT_ID
const network = process.env.NETWORK
const walletAddress = process.env.PUBLIC_KEY


const Deployment = async (network, projectID, txType) => {
  try {

    // Set initial txReceipt and gas price and gasIncrement
    let gasPrice = 0
    let txReceipt = null
    let retry = 0

    // later we can change this to mumbai
    // Configuring the connection to an Rinkeby node
    const provider = new ethers.providers.InfuraProvider(
      network,
      projectID
    );

    // Use your wallet's private key to deploy the contract
    const signer = new ethers.Wallet(privateKey, provider)

    // Read the contract artifact, which was generated by Hardhat
    const dir = prompt(
      "Enter the smart contract artifact file directory: "
    )
    if (!dir) return console.log("Contract path cannot be null")

    const metadata = JSON.parse(fs.readFileSync(dir))

    // Retry sending transaction utill success, 5 retries max
    while (txReceipt == null && retry < 5) {
      const nonce = await provider.getTransactionCount(walletAddress)

      // Get the transaction hash after the deployment
      const txHash = await handleDeployTx(signer, txType, nonce, metadata, provider)

      console.log("The contract is being mined...\n")
      console.log(`The gas price being used is ${gasInGWEI} GWEI.`)
      console.log(`The generated transaction hash is ${txHash}.\n`)
      console.log('While your contract is being mined, you can check your transaction at:');
      console.log(`https://rinkeby.etherscan.io/tx/${txHash}\n`)

      // Wait for confirmation and get the txReceipt or null
      txReceipt = await waitForConfirmation(provider, txHash)
      if (txReceipt == null) {
        retry += 1
        console.log("\nTransaction failed...Trying again!\n");
      }
    }
    // Wait for the contract to get mined
    console.log(`Deployment successful! Contract Address: ${contract.address}`)

    // Return the success receipt
    if (txReceipt !== null) {
      console.log(
          "Transaction was mined successfully and confirmed by 64 blocks"
      )
      return txReceipt
    }
    console.log("Transaction failed even after 5 retries")
    // Return the failed txReceipt
    return (txReceipt = await provider.getTransactionReceipt(txHash))
    
  } catch (error) {
    console.log("error in Deployment", error)
    return "error in Deployment"
  }
}

async function startDeployment() {
  console.log("\nStarting the transaction process.\n")
  const txType = prompt(
    "Enter the transaction type (1 for legacy || 2 for EIP-1559): "
  )
  if (!txType) return console.log("Transaction type cannot be null")

  if (txType !== "1" && txType !== "2")
    return console.log(`Transaction type ${txType} is unsupported`)

  console.log("Fetching all the necessary data to start mining.\n")

  const txReceipt = await Deployment(network, projectID, txType)

  // Store the success txReceipt in Redis DB & JSON file
  const mappedReceipt = await dataMapping(txReceipt)
  await saveReceipt(mappedReceipt)
  await redisDB(mappedReceipt)
}

startDeployment()
  .then(() => {
    console.log("\nTransaction process has ended\n\n")
    process.exit(0)
  })
  .catch((error) => {
    console.error(error)
    process.exit(1)
  }
  )    
